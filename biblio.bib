@Article{JGar98,
  author =       {Jacques Garrigue},
  title =        {{Programming with polymorphic variants}},
  journal =      {{ML Workshop}},
  year =         {1998},
  url = {https://www.math.nagoya-u.ac.jp/~garrigue/papers/variants.pdf}
}

@Article{JGar00,
  author =       {Jacques Garrigue},
  title =        {{Code reuse through polymorphic variants}},
  journal =      {{ML Workshop}},
  year =         {2000},
  url = {https://www.math.nagoya-u.ac.jp/~garrigue/papers/variant-reuse.pdf}
}

@Article{BonWeis18,
  author =       {Richard Bonichon and Pierre Weis},
  title =        {Format unraveled},
  journal =      {JFLA},
  year =         {2018},
  url = {https://hal.archives-ouvertes.fr/hal-01503081/file/format-unraveled.pdf},
  OPTkey =       {},
  OPTvolume =    {},
  OPTnumber =    {},
  OPTpages =     {},
  OPTmonth =     {},
  OPTnote =      {},
  OPTannote =    {}
}


@book{Oka98,
author = {Okasaki, Chris},
title = {Purely Functional Data Structures},
year = {1998},
isbn = {0521631246},
publisher = {Cambridge University Press},
address = {USA}
}

  
@book{RWOCaml,
  title = {{Real World OCaml}},
  author = {Hickey, Jason and Madhavapeddy, Anil and Minsky, Yaron},
  editor = {O'Reilly},
  year = {2013},
  note = {http://dev.realworldocaml.org/P}
}



@Article{GCRWOC,
  author =    {Hickey, Jason and Madhavapeddy, Anil and Minsky, Yaron},
  title =        {Understanding the Garbage Collector},
  year =         {2020},
  url = {http://dev.realworldocaml.org/garbage-collector.html},
  OPTkey =       {},
  OPTvolume =    {},
  OPTnumber =    {},
  OPTpages =     {},
  OPTmonth =     {},
  OPTnote =      {},
  OPTannote =    {}
}

@Article{lowLevelOCaml,
  OPTkey =       {},
  author =    {Hickey, Jason and Madhavapeddy, Anil and Minsky, Yaron},
  title =     {Memory representation of values},
  OPThowpublished = {},
  OPTmonth =     {},
  year =      {2014},
  url =      {http://dev.realworldocaml.org/runtime-memory-layout.html},
  OPTannote =    {}
}

@Article{bestFitGC,
  OPTkey =       {},
  author =    {Thomas Blanc},
  title =     {{OCaml new best fit GC}},
  OPThowpublished = {},
  OPTmonth =     {},
  year =      {2020},
  url =      {https://www.ocamlpro.com/2020/03/23/ocaml-new-best-fit-garbage-collector/},
  OPTannote =    {}
}


@Article{Sche12a,
  author =    {Gabriel Scherer},
  title =     {{Resolving field names}},
  year =      {2012},
  url =      {http://gallium.inria.fr/~scherer/gagallium/resolving-field-names/},
}

@Article{Sche12b,
  author =    {Gabriel Scherer},
  title =     {{Resolving field names (part 2)}},
  year =      {2012},
  url =      {http://gallium.inria.fr/~scherer/gagallium/resolving-field-names-2/},
}



@InProceedings{Yak08,
  author =       {Boris Yakobowski},
  title =        {{Le caractère ` à la rescousse: Factorisation et réutilisation de code grâce aux variants polymorphes}},
  OPTcrossref =  {},
  OPTkey =       {},
  booktitle = {JFLA},
  year =      {2008},
  OPTeditor =    {},
  OPTvolume =    {},
  OPTnumber =    {},
  OPTseries =    {},
  OPTpages =     {},
  OPTmonth =     {},
  OPTaddress =   {},
  OPTorganization = {},
  OPTpublisher = {},
  OPTnote =      {},
  OPTannote =    {},
  url = {http://www.yakobowski.org/publis/2008/jfla08.pdf}
}

@article{LFeMar01,
author = {Le Fessant, Fabrice and Maranget, Luc},
title = {Optimizing Pattern Matching},
year = {2001},
issue_date = {October 2001},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {36},
number = {10},
issn = {0362-1340},
url = {https://doi.org/10.1145/507669.507641},
doi = {10.1145/507669.507641},
journal = {SIGPLAN Not.},
month = oct,
pages = {26–37},
numpages = {12}
}

@article{OCamlManual,
  author =    {Xavier Leroy and Damien Doligez and Alain Frisch and Jacques Garrigue and Didier RémyP and Jérôme Vouillon },
  title =     {The OCaml system release 4.10},
  url = {https://caml.inria.fr/pub/docs/manual-ocaml/},
  OPThowpublished = {},
  OPTmonth =     {},
  year =      {2020},
  OPTnote =      {},
  OPTannote =    {}
}

@inproceedings{PotRG06POPL,
  author = {François Pottier and Yann Régis-Gianas},
  title = {Stratified type inference for generalized algebraic
                 data types},
  booktitle = {ACM Symposium on Principles of Programming Languages
                 (POPL)},
  address = {Charleston, South Carolina},
  month = jan,
  year = {2006},
  pages = {232--244},
  url = {http://gallium.inria.fr/~fpottier/publis/pottier-regis-gianas-popl06.pdf},
  off = {http://dl.acm.org/authorize?N05378},
  doi = {http://doi.acm.org/10.1145/1111037.1111058},
  abstract = {We offer a solution to the type inference problem for
                 an extension of Hindley and Milner's type system with
                 generalized algebraic data types. Our approach is in
                 two strata. The bottom stratum is a core language that
                 marries type inference in the style of Hindley and
                 Milner with type checking for generalized algebraic
                 data types. This results in an extremely simple
                 specification, where case constructs must carry an
                 explicit type annotation and type conversions must be
                 made explicit. The top stratum consists of (two
                 variants of) an independent shape inference algorithm.
                 This algorithm accepts a source term that contains some
                 explicit type information, propagates this information
                 in a local, predictable way, and produces a new source
                 term that carries more explicit type information. It
                 can be viewed as a preprocessor that helps produce some
                 of the type annotations required by the bottom stratum.
                 It is proven sound in the sense that it never inserts
                 annotations that could contradict the type derivation
                 that the programmer has in mind.}
}



@article{ProgGADTS,
  author =    {Anil Madhavapeddy and Jeremy Yallop},
  title =        {{Programming with GADTS}},
  year =         {2014},
  url = {https://www.cl.cam.ac.uk/teaching/1415/L28/gadts.pdf}
}

@inproceedings{Pot16,
  author = {François Pottier},
  title = {Reachability and error diagnosis in {LR}(1) parsers},
  booktitle = {International Conference on Compiler Construction
                 (CC)},
  month = mar,
  year = {2016},
  pages = {88--98},
  url = {http://gallium.inria.fr/~fpottier/publis/fpottier-reachability-cc2016.pdf},
  doi = {http://dx.doi.org/10.1145/2892208.2892224},
  off = {http://dl.acm.org/authorize?N10538},
  abstract = {Given an LR(1) automaton, what are the states in which
                 an error can be detected? For each such ``error
                 state'', what is a minimal input sentence that causes
                 an error in this state? We propose an algorithm that
                 answers these questions. This allows building a
                 collection of pairs of an erroneous input sentence and
                 a (handwritten) diagnostic message, ensuring that this
                 collection covers every error state, and maintaining
                 this property as the grammar evolves. We report on an
                 application of this technique to the CompCert ISO C99
                 parser, and discuss its strengths and limitations.}
}

@inproceedings{PotRG06,
  author = {François Pottier and Yann {Régis-Gianas}},
  title = {Towards efficient, typed {LR} parsers},
  url = {http://gallium.inria.fr/~fpottier/publis/fpottier-regis-gianas-typed-lr.pdf},
  off = {http://dx.doi.org/10.1016/j.entcs.2005.11.044},
  month = mar,
  year = {2006},
  pages = {155--180},
  booktitle = {ACM Workshop on ML (ML)},
  series = {Electronic Notes in Theoretical Computer Science},
  volume = {148},
  number = {2},
  abstract = {The LR parser generators that are bundled with many
                 functional programming language implementations produce
                 code that is untyped, needlessly inefficient, or both.
                 We show that, using generalized algebraic data types,
                 it is possible to produce parsers that are well-typed
                 (so they cannot unexpectedly crash or fail) and
                 nevertheless efficient. This is a pleasing result as
                 well as an illustration of the new expressiveness
                 offered by generalized algebraic data types.}
}

@Article{ClassicML,
  author =       {Christoph Kreitz and Vincent Rahli},
  title =        {Introduction to Classic ML},
  year =         {2011},
  url = {http://www.nuprl.org/software/eventml/KreitzandRahli-ClassicML.pdf},
  OPTkey =       {},
  OPTvolume =    {},
  OPTnumber =    {},
  OPTpages =     {},
  OPTmonth =     {},
  OPTnote =      {},
  OPTannote =    {}
}

